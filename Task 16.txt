#nullable disable
using System;

public class MyLinkedList<T>
{
    private class Node
    {
        public T item;
        public Node prev;
        public Node next;

        public Node(Node prev, T item, Node next)
        {
            this.prev = prev;
            this.item = item;
            this.next = next;
        }
    }

    private Node first; // указатель на первый элемент
    private Node last;  // указатель на последний элемент
    private int size;   // количество элементов

    // 1) конструктор пустого списка
    public MyLinkedList()
    {
        first = null;
        last = null;
        size = 0;
    }

    // 2) конструктор из массива
    public MyLinkedList(T[] a)
    {
        first = null;
        last = null;
        size = 0;

        if (a == null)
        {
            throw new ArgumentNullException(nameof(a));
        }

        AddAll(a);
    }

    // вспомогательные методы

    // для добавления узла в конец
    private void LinkLast(T e)
    {
        Node newNode = new Node(last, e, null);
        if (last == null)
        {
            first = newNode;
        }
        else
        {
            last.next = newNode;
        }

        last = newNode;
        size++;
    }

    // для добавления узла в начало
    private void LinkFirst(T e)
    {
        Node newNode = new Node(null, e, first);
        if (first == null)
        {
            last = newNode;
        }
        else
        {
            first.prev = newNode;
        }

        first = newNode;
        size++;
    }

    // для вставки перед узлом node
    private void LinkBefore(T e, Node node)
    {
        Node prev = node.prev;
        Node newNode = new Node(prev, e, node);
        node.prev = newNode;

        if (prev == null)
        {
            first = newNode;
        }
        else
        {
            prev.next = newNode;
        }

        size++;
    }

    // для удаления узла и возврата его значения
    private T Unlink(Node node)
    {
        Node prev = node.prev;
        Node next = node.next;

        if (prev == null)
        {
            first = next;
        }
        else
        {
            prev.next = next;
        }

        if (next == null)
        {
            last = prev;
        }
        else
        {
            next.prev = prev;
        }

        size--;
        T element = node.item;
        node.item = default;
        node.prev = null;
        node.next = null;
        return element;
    }

    // для получения узла по индексу
    private Node GetNode(int index)
    {
        if (index < 0 || index >= size)
        {
            throw new ArgumentOutOfRangeException(nameof(index), "Индекс вне диапазона.");
        }

        Node current;

        if (index < size / 2)
        {
            current = first;
            for (int i = 0; i < index; i++)
            {
                current = current.next;
            }
        }
        else
        {
            current = last;
            for (int i = size - 1; i > index; i--)
            {
                current = current.prev;
            }
        }

        return current;
    }

    // для проверки, содержится ли value в массиве a
    private bool ArrayContains(T[] a, T value)
    {
        foreach (T item in a)
        {
            if (object.Equals(item, value))
            {
                return true;
            }
        }

        return false;
    }

    // основные методы

    // 3) для добавления элемента в конец
    public void Add(T e)
    {
        AddLast(e);
    }

    // 4) для добавления всех элементов массива
    public void AddAll(T[] a)
    {
        if (a == null)
        {
            throw new ArgumentNullException(nameof(a));
        }

        for (int i = 0; i < a.Length; i++)
        {
            AddLast(a[i]);
        }
    }

    // 5) для очистки списка
    public void Clear()
    {
        Node current = first;
        while (current != null)
        {
            Node next = current.next;
            current.item = default;
            current.prev = null;
            current.next = null;
            current = next;
        }

        first = null;
        last = null;
        size = 0;
    }

    // 6) для проверки наличия объекта
    public bool Contains(object o)
    {
        return IndexOf(o) != -1;
    }

    // 7) для проверки наличия всех элементов массива
    public bool ContainsAll(T[] a)
    {
        if (a == null)
        {
            throw new ArgumentNullException(nameof(a));
        }

        for (int i = 0; i < a.Length; i++)
        {
            if (!Contains(a[i]))
            {
                return false;
            }
        }

        return true;
    }

    // 8) для проверки, пуст ли список
    public bool IsEmpty()
    {
        return size == 0;
    }

    // 9) удаление одного объекта o
    public bool Remove(object o)
    {
        Node current = first;
        while (current != null)
        {
            if (object.Equals(current.item, o))
            {
                Unlink(current);
                return true;
            }
            current = current.next;
        }

        return false;
    }

    // 10) удаление всех объектов из массива a
    public bool RemoveAll(T[] a)
    {
        if (a == null)
        {
            throw new ArgumentNullException(nameof(a));
        }

        bool changed = false;

        Node current = first;
        while (current != null)
        {
            Node next = current.next;
            if (ArrayContains(a, current.item))
            {
                Unlink(current);
                changed = true;
            }
            current = next;
        }

        return changed;
    }

    // 11) оставить только элементы из массива a
    public bool RetainAll(T[] a)
    {
        if (a == null)
        {
            throw new ArgumentNullException(nameof(a));
        }

        bool changed = false;

        Node current = first;
        while (current != null)
        {
            Node next = current.next;
            if (!ArrayContains(a, current.item))
            {
                Unlink(current);
                changed = true;
            }
            current = next;
        }

        return changed;
    }

    // 12) размер списка
    public int Size()
    {
        return size;
    }

    // 13) массив object[] со всеми элементами
    public object[] ToArray()
    {
        object[] result = new object[size];
        Node current = first;
        int index = 0;

        while (current != null)
        {
            result[index] = current.item;
            index++;
            current = current.next;
        }

        return result;
    }

    // 14) массив T[] со всеми элементами
    public T[] ToArray(T[] a)
    {
        if (a == null || a.Length < size)
        {
            a = new T[size];
        }

        Node current = first;
        int index = 0;

        while (current != null)
        {
            a[index] = current.item;
            index++;
            current = current.next;
        }

        return a;
    }

    // 15) добавление по индексу
    public void Add(int index, T e)
    {
        if (index < 0 || index > size)
        {
            throw new ArgumentOutOfRangeException(nameof(index));
        }

        if (index == size)
        {
            AddLast(e);
        }
        else if (index == 0)
        {
            AddFirst(e);
        }
        else
        {
            Node node = GetNode(index);
            LinkBefore(e, node);
        }
    }

    // 16) добавление массива по индексу
    public void AddAll(int index, T[] a)
    {
        if (a == null)
        {
            throw new ArgumentNullException(nameof(a));
        }

        if (index < 0 || index > size)
        {
            throw new ArgumentOutOfRangeException(nameof(index));
        }

        int currentIndex = index;
        for (int i = 0; i < a.Length; i++)
        {
            Add(currentIndex, a[i]);
            currentIndex++;
        }
    }

    // 17) получение элемента по индексу
    public T Get(int index)
    {
        Node node = GetNode(index);
        return node.item;
    }

    // 18) индекс первого вхождения объекта
    public int IndexOf(object o)
    {
        int index = 0;
        Node current = first;

        while (current != null)
        {
            if (object.Equals(current.item, o))
            {
                return index;
            }
            current = current.next;
            index++;
        }

        return -1;
    }

    // 19) индекс последнего вхождения объекта
    public int LastIndexOf(object o)
    {
        int index = size - 1;
        Node current = last;

        while (current != null)
        {
            if (object.Equals(current.item, o))
            {
                return index;
            }
            current = current.prev;
            index--;
        }

        return -1;
    }

    // 20) удаление по индексу
    public T Remove(int index)
    {
        Node node = GetNode(index);
        return Unlink(node);
    }

    // 21) замена по индексу
    public T Set(int index, T e)
    {
        Node node = GetNode(index);
        T old = node.item;
        node.item = e;
        return old;
    }

    // 22) подсписок [fromIndex; toIndex)
    public MyLinkedList<T> SubList(int fromIndex, int toIndex)
    {
        if (fromIndex < 0 || toIndex > size || fromIndex > toIndex)
        {
            throw new ArgumentOutOfRangeException("Неверный диапазон индексов.");
        }

        MyLinkedList<T> sub = new MyLinkedList<T>();

        Node current = GetNode(fromIndex);
        for (int i = fromIndex; i < toIndex; i++)
        {
            sub.AddLast(current.item);
            current = current.next;
        }

        return sub;
    }

    // 23) element() — вернуть голову без удаления (как Queue.Element)
    public T Element()
    {
        if (IsEmpty())
        {
            throw new InvalidOperationException("Список пуст.");
        }

        return first.item;
    }

    // 24) offer() — попытка добавить, возвращает true, если добавлен
    public bool Offer(T obj)
    {
        AddLast(obj);
        return true;
    }

    // 25) peek() — вернуть голову или default, если пуст
    public T Peek()
    {
        if (IsEmpty())
        {
            return default;
        }

        return first.item;
    }

    // 26) poll() — удалить голову и вернуть её, либо default, если пуст
    public T Poll()
    {
        if (IsEmpty())
        {
            return default;
        }

        return RemoveFirst();
    }

    // 27) добавить в голову
    public void AddFirst(T obj)
    {
        LinkFirst(obj);
    }

    // 28) добавить в хвост
    public void AddLast(T obj)
    {
        LinkLast(obj);
    }

    // 29) получить первый элемент без удаления
    public T GetFirst()
    {
        if (IsEmpty())
        {
            throw new InvalidOperationException("Список пуст.");
        }

        return first.item;
    }

    // 30) получить последний элемент без удаления
    public T GetLast()
    {
        if (IsEmpty())
        {
            throw new InvalidOperationException("Список пуст.");
        }

        return last.item;
    }

    // 31) offerFirst — попытка добавить в голову
    public bool OfferFirst(T obj)
    {
        AddFirst(obj);
        return true;
    }

    // 32) offerLast — попытка добавить в хвост
    public bool OfferLast(T obj)
    {
        AddLast(obj);
        return true;
    }

    // 33) pop() — вернуть голову с удалением (как стек)
    public T Pop()
    {
        if (IsEmpty())
        {
            throw new InvalidOperationException("Список пуст.");
        }

        return RemoveFirst();
    }

    // 34) push() — добавить в голову (как стек)
    public void Push(T obj)
    {
        AddFirst(obj);
    }

    // 35) peekFirst — вернуть голову или default, если пуст
    public T PeekFirst()
    {
        return Peek();
    }

    // 36) peekLast — вернуть хвост или default, если пуст
    public T PeekLast()
    {
        if (IsEmpty())
        {
            return default;
        }

        return last.item;
    }

    // 37) pollFirst — вернуть голову с удалением или default, если пуст
    public T PollFirst()
    {
        return Poll();
    }

    // 38) pollLast — вернуть хвост с удалением или default, если пуст
    public T PollLast()
    {
        if (IsEmpty())
        {
            return default;
        }

        return RemoveLast();
    }

    // 39) removeLast — вернуть хвост с удалением, бросить исключение, если пуст
    public T RemoveLast()
    {
        if (IsEmpty())
        {
            throw new InvalidOperationException("Список пуст.");
        }

        return Unlink(last);
    }

    // 40) removeFirst — вернуть голову с удалением, бросить исключение, если пуст
    public T RemoveFirst()
    {
        if (IsEmpty())
        {
            throw new InvalidOperationException("Список пуст.");
        }

        return Unlink(first);
    }

    // 41) удалить последнее вхождение obj
    public bool RemoveLastOccurrence(object obj)
    {
        Node current = last;
        while (current != null)
        {
            if (object.Equals(current.item, obj))
            {
                Unlink(current);
                return true;
            }
            current = current.prev;
        }

        return false;
    }

    // 42) удалить первое вхождение obj
    public bool RemoveFirstOccurrence(object obj)
    {
        return Remove(obj);
    }
}

class Program
{
    static void Main(string[] args)
    {
        MyLinkedList<int> list = new MyLinkedList<int>();

        Console.WriteLine("Добавляем элементы 10, 20, 30 в конец:");
        list.Add(10);
        list.Add(20);
        list.Add(30);
        PrintList(list);

        Console.WriteLine("\nДобавляем 5 в начало (AddFirst):");
        list.AddFirst(5);
        PrintList(list);

        Console.WriteLine("\nДобавляем 40 в конец (AddLast):");
        list.AddLast(40);
        PrintList(list);

        Console.WriteLine("\nЭлемент по индексу 2 (Get): " + list.Get(2));
        Console.WriteLine("IndexOf(20): " + list.IndexOf(20));
        Console.WriteLine("LastIndexOf(20): " + list.LastIndexOf(20));

        Console.WriteLine("\nУдаляем элемент по индексу 1 (Remove):");
        int removed = list.Remove(1);
        Console.WriteLine("Удалён: " + removed);
        PrintList(list);

        Console.WriteLine("\nПервый элемент (GetFirst): " + list.GetFirst());
        Console.WriteLine("Последний элемент (GetLast): " + list.GetLast());

        Console.WriteLine("\nИспользуем Pop как стек:");
        int popValue = list.Pop();
        Console.WriteLine("Pop вернул: " + popValue);
        PrintList(list);

        Console.WriteLine("\nИспользуем Push(99) как стек:");
        list.Push(99);
        PrintList(list);

        Console.WriteLine("\nSubList(1, 3):");
        MyLinkedList<int> sub = list.SubList(1, 3);
        PrintList(sub);

        Console.WriteLine("\nОчистка списка (Clear):");
        list.Clear();
        PrintList(list);

        Console.WriteLine("\nРабота программы завершена.");
    }

    // простой вывод содержимого списка
    static void PrintList(MyLinkedList<int> list)
    {
        Console.Write("Содержимое списка: ");
        if (list.IsEmpty())
        {
            Console.WriteLine("список пуст ._.");
            return;
        }

        int[] data = list.ToArray(new int[list.Size()]);
        for (int i = 0; i < data.Length; i++)
        {
            Console.Write(data[i] + " ");
        }
        Console.WriteLine();
    }
}
